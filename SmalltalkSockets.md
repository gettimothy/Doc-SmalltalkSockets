# Table of Contents1.  [SmalltalkSockets](#org45710a9)    1.  [Introduction](#orgccae446)    2.  [Bottom The Kernel](#org6969d9d)    3.  [Simple Example Via The Squeak Wiki](#orgfa0e122)    4.  [An Example From Marcel Taeumel](#orgfa2fda6)    5.  [Bibliography](#org46ad048)<a id="org45710a9"></a># SmalltalkSockets<a id="orgccae446"></a>## Introduction    basic documentation and examples of squeak and pharo networking via sockets.        I am thinking a "bottom up" discussion will be useful.<a id="org6969d9d"></a>## Bottom The Kernel    Dragons be there.    The Kernel-Networking package has a bunch of stuff.    Seriously, I have no idea how to even begin.<a id="orgfa0e122"></a>## Simple Example Via The Squeak Wiki        Via http://wiki.squeak.org/squeak/325  comes this simple, introductory example        In a Workspace/Playground type:           Socket newTCP        and inspect it twice - this gives you two inspectors. Move them so that they are side by side.         In the left one type            self listenOn: 8080        in the bottom evaluation pane and do-it.     Click on 'self' in the inspector and check that the socket is waiting.             Go the right hand inspector and type            self connectTo: NetNameResolver localHostAddress port: 8080        and do-it.        If you have both inspectors showing the state of 'self' then you should immediately see that they have both 'connected'.         In the right hand one then type            self sendData: 'hello'        and do-it.             And in the left one type:             self receiveData        and print-it.     It should say 'hello'.             You can then do anything you like in these two inspectors.     You have successfully created a TCP connection and sent some data.        To then find out what other messages you can send you can either browse the class directly by alt-b on 'self' or look at its protocol through alt-p.        Rather than using Socket>>listenOn: you could use =Socket>>listenOn:backlogSize: and then inspect    self accept to get an inspector for each incoming connection.        Some messages that you can send to sockets can block for a reasonable timeout depending on various things so you can always the three key combo:“alt-.” to get the UI back if it seems to freeze.        Before you close the inspectors it is worth doing a            self closeAndDestroy        in each one so that you release the socket's resources.<a id="orgfa2fda6"></a>## An Example From Marcel Taeumel    | hostName port serverSocket serverProcess clientSocket |        hostName := NetNameResolver localHostName.    port := 1234.    data := 'Hello World!'.        serverSocket := Socket newTCP.    serverSocket listenOn: port.        serverProcess := [    	| receivedData |    	serverSocket waitForConnectionFor: 10 "seconds".    	Transcript showln: 'Server accepted client connection'.	    	receivedData := serverSocket receiveData.    	Transcript showln: 'Data received: ', receivedData.    	serverSocket closeAndDestroy.    ] newProcess.    serverProcess priority: Processor userBackgroundPriority.    serverProcess resume. "or use #forkAt: directly on block"        clientSocket := Socket newTCP.    clientSocket    	connectTo: (NetNameResolver addressFromString: hostName)    	port: port.    Transcript showln: 'Client connected to server'.        Transcript showln: 'Data sent: ', (clientSocket sendData: data), ' bytes'.    clientSocket closeAndDestroy.<a id="org46ad048"></a>## Bibliography    http://wiki.squeak.org/squeak/325    https://en.wikipedia.org/wiki/List_of_TCP_and_UDP_port_numbers